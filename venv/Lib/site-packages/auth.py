from fastapi import FastAPI, HTTPException, Depends, Security, Request
import jwt #pip install pyjwt https://pypi.org/project/PyJWT/
from pydantic import BaseModel
from fastapi.encoders import jsonable_encoder
from fastapi.security import APIKeyHeader
from routes import get_user
from datetime import datetime, timedelta
from passlib.context import CryptContext
from secrecy import *
from sqlalchemy.orm import Session

# JWT_SECRET = "cairocoders123456789"
# ALGORITHM = "HS256"
# ACCESS_TOKEN_EXPIRE_MINUTES = 800

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

user = {
    "id": "6546546",
    "username": "cairocoders",
    "password": "123456ednalan",
}

# Authenticate the user
async def authenticate_user(username: str, password: str, db: Session):
    user = await get_user.filter(id=payload['sub']).first()
    if not user:
        raise jwt.JsonHTTPException()
    if not pwd_context.verify(password, user.hashed_password):
        return False
    return user

def create_access_token(payload: dict, expires_delta: timedelta | None = None):
    to_encode = payload.copy()
    if expires_delta:
        expire = datetime.now.timezone.utcnow() + expires_delta
    else:
        expire = datetime.now.timezone.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, JWT_SECRET, algorithm=ALGORITHM)
    return encoded_jwt
# what do we do with the payload?.. pass user object?
# token = jwt.encode(payload={'sub': user.id}, key=JWT_SECRET, algorithm='HS256')

async def check_access_token(
    request: Request,
    authorization_header: str = Security(APIKeyHeader(name='Authorization', auto_error=False))
) -> str:
    # Проверяем, что токен передан
    if authorization_header is None:
        raise HTTPException(status_code=401, detail="Incorrect user login or password, unauthorized")
        # raise JsonHTTPException()

    # Проверяем токен на соответствие форме
    if 'Bearer ' not in authorization_header:
        # raise JsonHTTPException()
        raise HTTPException(status_code=401, detail="Incorrect user login or password, unauthorized")

    # Убираем лишнее из токена
    clear_token = authorization_header.replace('Bearer ', '')

    try:
        # Проверяем валидность токена
        payload = jwt.decode(jwt=clear_token, key=JWT_SECRET, algorithms=['HS256', 'RS256'])
    except jwt.InvalidTokenError:
        # В случае невалидности возвращаем ошибку
        raise jwt.JsonHTTPException()
    
    # Идентифицируем пользователя
    # user = await APIUser.filter(id=payload['sub']).first()
    user = await get_user.filter(id=payload['sub']).first()
    if not user:
        raise jwt.JsonHTTPException()

    request.state.user = user

    return authorization_header

oauth2_scheme = Security.OAuth2PasswordBearer(tokenUrl="token")

def verify_token(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=403, detail="Token is invalid or expired")
        return payload
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=403, detail="Token is invalid or expired")
    
# just so you know where the class is placed
# Security.OAuth2PasswordRequestForm
