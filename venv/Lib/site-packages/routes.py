from fastapi import status, APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from database import get_db
from typing import List, Dict, Any
from models import User, Product, Cart, Order
from schemas import IProductItem
from pydantic import BaseModel
from sqlalchemy.orm.attributes import flag_modified
from auth import get_current_user, bcrypt_context, ACCESS_TOKEN_EXPIRE_MINUTES, authenticate_user, create_access_token, user_dependency
from fastapi.security import OAuth2PasswordRequestForm
from datetime import timedelta

router = APIRouter()

# Схемы
class UserCreate(BaseModel):
    id: str  # Новый ID пользователя
    username: str
    email: str
    password: str
    active: bool = True


class ProductCreate(BaseModel):
    name: str
    price: int


class CartCreate(BaseModel):
    cart_id: str
    user_id: str


class CartAdd(BaseModel):
    product_id: int
    quantity: int


class CartUpdate(BaseModel):
    product_id: int
    quantity: int


class CartResponse(BaseModel):
    id: str
    user_id: str
    products: List[Dict[str, int]]  # Массив объектов {product_id, quantity}

class OrderCreate(BaseModel):
    user_id: str
    order_details: str

# Пользователи
@router.post("/users/")
def create_user(user: UserCreate, db: Session = Depends(get_db)):
    db_user = User(
        id=user.id,
        username=user.username,
        email=user.email,
        password=bcrypt_context.hash(user.password),
        active=user.active,
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

@router.post("/users/token")
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends(),
                           db: Session = Depends(get_db)):
    user = await authenticate_user(form_data.username, form_data.password, db)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(user.username, user.id, timedelta(minutes=20))
    # access_token = create_access_token(
    #     data={"sub": user.username}, expires_delta=access_token_expires
    # )
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/users/{user_id}")
def get_user(user_id: str, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user

@router.get("/users/")
def user(user: user_dependency, db: Session = Depends(get_db)):
    if not user:
        raise HTTPException(status_code=401, detail='Authentication Failed')
    return {"User": user}

# @router.get("/users/{user_id}")
# async def user(user: Depends(get_current_user), db: Session = Depends(get_db)):
#     if user is None:
#         raise HTTPException(status_code=401, detail='Authentication Failed')
#     return {"User": user}

# @app.get("/", status_code=status.HTTP_200_OK)
# async def user(user: None, db: db_dependency):
#     if user is None:
#         raise HTTPException(status_code=401, detail='Authentication Failed')
#     return {"User": user}


# Товары магазина
@router.post("/products/", response_model=IProductItem)
def create_product(product: IProductItem, db: Session = Depends(get_db)):
    db_product = Product(
        name=product.name,
        description=product.description,
        price=product.price,
        discount=product.discount,
        hit=product.hit,
        release_date=product.releaseDate,
        brand=product.brand,
        digital=product.digital,
        categories=product.categories,
        cover=product.cover,
        amount=product.amount,
        images=[image.dict() for image in product.images],
        reviews=product.reviews,
    )
    db.add(db_product)
    db.commit()
    db.refresh(db_product)
    return db_product

@router.get("/products/")
def list_products(db: Session = Depends(get_db)):
    return db.query(Product).all()

@router.get("/products/{product_id}", response_model=IProductItem)
def get_product(product_id: int, db: Session = Depends(get_db)):
    product = db.query(Product).filter(Product.id == product_id).first()
    if not product:
        raise HTTPException(status_code=404, detail="Product not found")
    return product

# Корзина
@router.post("/carts/")
def create_cart(cart: CartCreate, db: Session = Depends(get_db)):
    """Создать пустую корзину для пользователя."""
    existing_cart = db.query(Cart).filter(Cart.user_id == cart.user_id).first()
    if existing_cart:
        raise HTTPException(status_code=400, detail="Cart for user already exists")
    new_cart = Cart(id=cart.cart_id, user_id=cart.user_id, products=[])
    db.add(new_cart)
    db.commit()
    db.refresh(new_cart)
    return new_cart

@router.post("/carts/{cart_id}/add")
def add_to_cart(cart_id: str, item: CartAdd, db: Session = Depends(get_db)):
    """Добавить продукт в корзину."""
    cart = db.query(Cart).filter(Cart.id == cart_id).first()
    if not cart:
        raise HTTPException(status_code=404, detail="Cart not found")

    # Создаем копию массива продуктов
    updated_products = cart.products.copy()

    # Проверяем, есть ли продукт уже в корзине
    for product in updated_products:
        if product["product_id"] == item.product_id:
            product["quantity"] += item.quantity  # Увеличиваем количество
            break
    else:
        # Если продукта нет, добавляем новый элемент
        updated_products.append({"product_id": item.product_id, "quantity": item.quantity})

    # Обновляем поле products в корзине
    cart.products = updated_products

    db.commit()
    db.refresh(cart)
    return cart

@router.get("/carts/{user_id}", response_model=CartResponse)
def get_cart(user_id: str, db: Session = Depends(get_db)):
    """Получить содержимое корзины пользователя."""
    cart = db.query(Cart).filter(Cart.user_id == user_id).first()
    if not cart:
        raise HTTPException(status_code=404, detail="Cart not found")
    return cart

@router.put("/carts/{cart_id}/update")
def update_cart(cart_id: str, item: CartUpdate, db: Session = Depends(get_db)):
    """Изменить количество продукта в корзине."""
    cart = db.query(Cart).filter(Cart.id == cart_id).first()
    if not cart:
        raise HTTPException(status_code=404, detail="Cart not found")

    # Если cart.products - строка, преобразуем в список
    import json
    if isinstance(cart.products, str):
        cart_products = json.loads(cart.products)
    else:
        cart_products = cart.products or []

    # Логика обновления количества
    product_found = False
    for product in cart_products:
        if product["product_id"] == item.product_id:
            product["quantity"] = item.quantity
            product_found = True
            break

    if not product_found:
        raise HTTPException(status_code=404, detail="Product not found in cart")

    # Сохраняем изменения обратно в cart.products
    cart.products = cart_products

    # Указываем, что поле изменено
    flag_modified(cart, "products")
    db.commit()
    db.refresh(cart)

    return cart

@router.delete("/carts/{cart_id}/delete/{product_id}")
def delete_from_cart(cart_id: str, product_id: int, db: Session = Depends(get_db)):
    """Удалить продукт из корзины."""
    cart = db.query(Cart).filter(Cart.id == cart_id).first()
    if not cart:
        raise HTTPException(status_code=404, detail="Cart not found")
    
    # Создаем обновленный список продуктов без удаляемого
    updated_products = [product for product in cart.products if product["product_id"] != product_id]

    # Если продукт для удаления не найден
    if len(updated_products) == len(cart.products):
        raise HTTPException(status_code=404, detail="Product not found in cart")

    # Явно присваиваем обновленный массив продуктов
    cart.products = updated_products

    # Сохраняем изменения в базе данных
    db.commit()
    db.refresh(cart)
    return cart


# Заказы
@router.post("/orders/")
def create_order(order: OrderCreate, db: Session = Depends(get_db)):
    db_order = Order(user_id=order.user_id, order_details=order.order_details)
    db.add(db_order)
    db.commit()
    db.refresh(db_order)
    return db_order

@router.get("/orders/{user_id}")
def get_orders(user_id: str, db: Session = Depends(get_db)):
    orders = db.query(Order).filter(Order.user_id == user_id).all()
    return orders

@router.get("/orders/", response_model=List[Dict[str, Any]])
def get_all_orders(db: Session = Depends(get_db)):
    """Получить все заказы всех пользователей."""
    orders = db.query(Order).all()
    if not orders:
        return []
    
    return [{"id": order.id, "user_id": order.user_id, "order_details": order.order_details} for order in orders]